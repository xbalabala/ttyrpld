Index: linux-2.4.34/drivers/char/Config.in
===================================================================
--- linux-2.4.34.orig/drivers/char/Config.in
+++ linux-2.4.34/drivers/char/Config.in
@@ -11,6 +11,7 @@ if [ "$CONFIG_VT" = "y" ]; then
       bool '    Support for Lasi/Dino PS2 port' CONFIG_GSC_PS2
    fi
 fi
+bool 'rpldev hooks for tty logging' CONFIG_RPLDHK
 tristate 'Standard/generic (8250/16550 and compatible UARTs) serial support' CONFIG_SERIAL
 if [ "$CONFIG_SERIAL" = "y" ]; then
    bool '  Support for console on serial port' CONFIG_SERIAL_CONSOLE
Index: linux-2.4.34/drivers/char/tty_io.c
===================================================================
--- linux-2.4.34.orig/drivers/char/tty_io.c
+++ linux-2.4.34/drivers/char/tty_io.c
@@ -113,6 +113,18 @@ extern void disable_early_printk(void);
 #define SYSCONS_DEV MKDEV(TTYAUX_MAJOR,1)
 #define PTMX_DEV MKDEV(TTYAUX_MAJOR,2)
 
+#ifdef CONFIG_RPLDHK
+#	include <linux/km_rpldev.h>
+int (*rpl_open)(struct tty_struct *, struct tty_struct *, struct file *) = NULL;
+int (*rpl_read)(const char *, size_t, struct tty_struct *)               = NULL;
+int (*rpl_write)(const char *, size_t, struct tty_struct *)              = NULL;
+int (*rpl_lclose)(struct tty_struct *, struct tty_struct *)              = NULL;
+EXPORT_SYMBOL(rpl_open);
+EXPORT_SYMBOL(rpl_read);
+EXPORT_SYMBOL(rpl_write);
+EXPORT_SYMBOL(rpl_lclose);
+#endif
+
 #undef TTY_DEBUG_HANGUP
 
 #define TTY_PARANOIA_CHECK 1
@@ -1012,8 +1024,16 @@ static ssize_t tty_read(struct file * fi
 		i = -EIO;
 	tty_ldisc_deref(ld);
 	unlock_kernel();
-	if (i > 0)
+	if(i > 0) {
 		inode->i_atime = CURRENT_TIME;
+#ifdef CONFIG_RPLDHK
+		{
+			typeof(rpl_read) tmp = rpl_read;
+			if(tmp != NULL)
+				tmp(buf, i, tty);
+		}
+#endif
+        }
 	return i;
 }
 
@@ -1131,9 +1151,17 @@ static ssize_t tty_write(struct file * f
 	ld = tty_ldisc_ref_wait(tty);
 	if (!ld->write)
 		ret = -EIO;
-	else
+	else {
 		ret = do_tty_write(ld->write, tty, file,
 				(const unsigned char __user *)buf, count);
+#ifdef CONFIG_RPLDHK
+		{
+			typeof(rpl_write) tmp = rpl_write;
+			if(tmp != NULL)
+				tmp(buf, ret, tty);
+		}
+#endif
+	}
 	tty_ldisc_deref(ld);
 	return ret;
 }
@@ -1160,7 +1188,8 @@ static void release_mem(struct tty_struc
  * really quite straightforward.  The semaphore locking can probably be
  * relaxed for the (most common) case of reopening a tty.
  */
-static int init_dev(kdev_t device, struct tty_struct **ret_tty)
+static int init_dev(kdev_t device, struct tty_struct **ret_tty,
+    struct file *filp)
 {
 	struct tty_struct *tty, *o_tty;
 	struct termios *tp, **tp_loc, *o_tp, **o_tp_loc;
@@ -1607,6 +1636,14 @@ static void release_dev(struct file * fi
 	printk(KERN_DEBUG "freeing tty structure...");
 #endif
 
+#ifdef CONFIG_RPLDHK
+	{
+		typeof(rpl_lclose) tmp = rpl_lclose;
+		if(tmp != NULL)
+			tmp(tty, o_tty);
+	}
+#endif
+
 	/*
 	 * Prevent flush_to_ldisc() from rescheduling the work for later.  Then
 	 * kill any delayed work. As this is the final close it does not
@@ -1733,7 +1770,7 @@ retry_open:
 			     minor < driver->minor_start + driver->num ;
 			     minor++) {
 				device = MKDEV(driver->major, minor);
-				if (!init_dev(device, &tty)) goto ptmx_found; /* ok! */
+				if (!init_dev(device, &tty, filp)) goto ptmx_found; /* ok! */
 			}
 		}
 		return -EIO; /* no free ptys */
@@ -1753,7 +1790,7 @@ retry_open:
 #endif  /* CONFIG_UNIX_98_PTYS */
 	}
 
-	retval = init_dev(device, &tty);
+	retval = init_dev(device, &tty, filp);
 	if (retval)
 		return retval;
 
@@ -1820,6 +1857,14 @@ init_dev_done:
 			nr_warns++;
 		}
 	}
+
+#ifdef CONFIG_RPLDHK
+	{
+		typeof(rpl_open) tmp = rpl_open;
+		if(tmp != NULL)
+			tmp(tty, current->tty, filp);
+	}
+#endif
 	return 0;
 }
 
Index: linux-2.4.34/include/linux/km_rpldev.h
===================================================================
--- /dev/null
+++ linux-2.4.34/include/linux/km_rpldev.h
@@ -0,0 +1,12 @@
+#ifndef _LINUX_KM_RPLDEV_H
+#define _LINUX_KM_RPLDEV_H 1
+
+struct file;
+struct tty_struct;
+
+extern int (*rpl_open)(struct tty_struct *, struct tty_struct *, struct file *);
+extern int (*rpl_read)(const char *, size_t, struct tty_struct *);
+extern int (*rpl_write)(const char *, size_t, struct tty_struct *);
+extern int (*rpl_lclose)(struct tty_struct *, struct tty_struct *);
+
+#endif /* _LINUX_KM_RPLDEV_H */
