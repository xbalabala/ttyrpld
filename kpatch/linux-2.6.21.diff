Index: linux-2.6.21-rc5/drivers/char/tty_io.c
===================================================================
--- linux-2.6.21-rc5.orig/drivers/char/tty_io.c
+++ linux-2.6.21-rc5/drivers/char/tty_io.c
@@ -104,6 +104,19 @@
 
 #include <linux/kmod.h>
 
+#ifdef CONFIG_RPLDHK
+#	include <linux/compiler.h>
+#	include <linux/km_rpldev.h>
+int (*rpl_open)(struct tty_struct *, struct tty_struct *, struct file *) = NULL;
+int (*rpl_read)(const char __user *, size_t, struct tty_struct *)        = NULL;
+int (*rpl_write)(const char __user *, size_t, struct tty_struct *)       = NULL;
+int (*rpl_lclose)(struct tty_struct *, struct tty_struct *)              = NULL;
+EXPORT_SYMBOL(rpl_open);
+EXPORT_SYMBOL(rpl_read);
+EXPORT_SYMBOL(rpl_write);
+EXPORT_SYMBOL(rpl_lclose);
+#endif
+
 #undef TTY_DEBUG_HANGUP
 
 #define TTY_PARANOIA_CHECK 1
@@ -1671,8 +1684,16 @@ static ssize_t tty_read(struct file * fi
 		i = -EIO;
 	tty_ldisc_deref(ld);
 	unlock_kernel();
-	if (i > 0)
+	if(i > 0) {
 		inode->i_atime = current_fs_time(inode->i_sb);
+#ifdef CONFIG_RPLDHK
+		{
+			typeof(rpl_read) tmp = rpl_read;
+			if(tmp != NULL)
+				tmp(buf, i, tty);
+		}
+#endif
+        }
 	return i;
 }
 
@@ -1802,8 +1823,16 @@ static ssize_t tty_write(struct file * f
 	ld = tty_ldisc_ref_wait(tty);		
 	if (!ld->write)
 		ret = -EIO;
-	else
+	else {
 		ret = do_tty_write(ld->write, tty, file, buf, count);
+#ifdef CONFIG_RPLDHK
+		{
+			typeof(rpl_write) tmp = rpl_write;
+			if(tmp != NULL)
+				tmp(buf, ret, tty);
+		}
+#endif
+	}
 	tty_ldisc_deref(ld);
 	return ret;
 }
@@ -1893,7 +1922,7 @@ static void tty_line_name(struct tty_dri
  */
 
 static int init_dev(struct tty_driver *driver, int idx,
-	struct tty_struct **ret_tty)
+	struct tty_struct **ret_tty, struct file *filp)
 {
 	struct tty_struct *tty, *o_tty;
 	struct ktermios *tp, **tp_loc, *o_tp, **o_tp_loc;
@@ -2419,6 +2448,14 @@ static void release_dev(struct file * fi
 	clear_bit(TTY_LDISC, &tty->flags);
 	cancel_delayed_work(&tty->buf.work);
 
+#ifdef CONFIG_RPLDHK
+	{
+		typeof(rpl_lclose) tmp = rpl_lclose;
+		if(tmp != NULL)
+			tmp(tty, o_tty);
+	}
+#endif
+
 	/*
 	 * Wait for ->hangup_work and ->buf.work handlers to terminate
 	 */
@@ -2558,7 +2595,7 @@ retry_open:
 		return -ENODEV;
 	}
 got_driver:
-	retval = init_dev(driver, index, &tty);
+	retval = init_dev(driver, index, &tty, filp);
 	mutex_unlock(&tty_mutex);
 	if (retval)
 		return retval;
@@ -2613,6 +2650,14 @@ got_driver:
 	spin_unlock_irq(&current->sighand->siglock);
 	mutex_unlock(&tty_mutex);
 	put_pid(old_pgrp);
+
+#ifdef CONFIG_RPLDHK
+	{
+		typeof(rpl_open) tmp = rpl_open;
+		if(tmp != NULL)
+			tmp(tty, current->signal->tty, filp);
+	}
+#endif
 	return 0;
 }
 
@@ -2659,7 +2704,7 @@ static int ptmx_open(struct inode * inod
 	up(&allocated_ptys_lock);
 
 	mutex_lock(&tty_mutex);
-	retval = init_dev(ptm_driver, index, &tty);
+	retval = init_dev(ptm_driver, index, &tty, filp);
 	mutex_unlock(&tty_mutex);
 	
 	if (retval)
Index: linux-2.6.21-rc5/include/linux/km_rpldev.h
===================================================================
--- /dev/null
+++ linux-2.6.21-rc5/include/linux/km_rpldev.h
@@ -0,0 +1,14 @@
+#ifndef _LINUX_KM_RPLDEV_H
+#define _LINUX_KM_RPLDEV_H 1
+
+#include <linux/compiler.h>
+
+struct file;
+struct tty_struct;
+
+extern int (*rpl_open)(struct tty_struct *, struct tty_struct *, struct file *);
+extern int (*rpl_read)(const char __user *, size_t, struct tty_struct *);
+extern int (*rpl_write)(const char __user *, size_t, struct tty_struct *);
+extern int (*rpl_lclose)(struct tty_struct *, struct tty_struct *);
+
+#endif /* _LINUX_KM_RPLDEV_H */
Index: linux-2.6.21-rc5/security/Kconfig
===================================================================
--- linux-2.6.21-rc5.orig/security/Kconfig
+++ linux-2.6.21-rc5/security/Kconfig
@@ -95,5 +95,13 @@ config SECURITY_ROOTPLUG
 
 source security/selinux/Kconfig
 
+config RPLDHK
+	bool "rpldev hooks for tty logging"
+	---help---
+		Allows you to log any traffic running over the TTY driver.
+		It is way more useful, because it cannot be fooled by empty
+		or bogus .bash_history entries or even an SSH encrypted
+		channel.
+
 endmenu
 
